<?xml version="1.0" encoding="UTF-8"?><testrun duration="57" footerText="Generated by PyCharm on 3/6/18 11:35 AM" name="py.test in test_create_contact.py">
    <count name="total" value="7"/>
    <count name="failed" value="7"/>
    <config nameIsGenerated="true" configId="tests" name="py.test in test_create_contact.py">
        <option name="INTERPRETER_OPTIONS" value=""/>
        <option name="PARENT_ENVS" value="true"/>
        <envs/>
        <option name="SDK_HOME" value="E:\GitHub\Python_for_testers\env\Scripts\python.exe"/>
        <option name="WORKING_DIRECTORY" value=""/>
        <option name="IS_MODULE_SDK" value="false"/>
        <option name="ADD_CONTENT_ROOTS" value="true"/>
        <option name="ADD_SOURCE_ROOTS" value="true"/>
        <module name="Python_for_testers"/>
        <option name="SCRIPT_NAME" value=""/>
        <option name="CLASS_NAME" value=""/>
        <option name="METHOD_NAME" value=""/>
        <option name="FOLDER_NAME" value=""/>
        <option name="TEST_TYPE" value="TEST_SCRIPT"/>
        <option name="PATTERN" value=""/>
        <option name="USE_PATTERN" value="false"/>
        <option name="testToRun" value="E:\GitHub\Python_for_testers\tests"/>
        <option name="keywords" value=""/>
        <option name="params" value=""/>
        <option name="USE_PARAM" value="false"/>
        <option name="USE_KEYWORD" value="false"/>
        <option name="INTERPRETER_OPTIONS" value=""/>
        <option name="PARENT_ENVS" value="true"/>
        <envs/>
        <option name="SDK_HOME" value="E:\GitHub\Python_for_testers\env\Scripts\python.exe"/>
        <option name="WORKING_DIRECTORY" value="/home/sqa-user/PycharmProjects/Python_for_testers/tests"/>
        <option name="IS_MODULE_SDK" value="true"/>
        <option name="ADD_CONTENT_ROOTS" value="true"/>
        <option name="ADD_SOURCE_ROOTS" value="true"/>
        <option name="_new_keywords" value="&quot;&quot;"/>
        <option name="_new_additionalArguments" value="&quot;&quot;"/>
        <option name="_new_legacyInformationCopiedToNew" value="true"/>
        <option name="_new_target" value="&quot;/home/sqa-user/PycharmProjects/Python_for_testers/tests/test_create_contact.py&quot;"/>
        <option name="_new_targetType" value="&quot;PATH&quot;"/>
    </config>
    <suite duration="57" locationUrl="python&lt;/home/sqa-user/PycharmProjects/Python_for_testers/tests&gt;://test_create_contact" name="test_create_contact" status="failed">
        <suite duration="53" locationUrl="python&lt;/home/sqa-user/PycharmProjects/Python_for_testers/tests&gt;://test_create_contact.test_create_contact" name="test_create_contact" status="failed">
            <test duration="13" locationUrl="python&lt;/home/sqa-user/PycharmProjects/Python_for_testers/tests&gt;://test_create_contact.test_create_contact." name="(None:::)" status="failed">
                <output type="stdout">E
</output>
                <output type="stderr">test setup failed
self = &amp;lt;selenium.webdriver.firefox.service.Service object at 0x7fd15503b080&amp;gt;
    def start(self):
        &amp;quot;&amp;quot;&amp;quot;
            Starts the Service.
    
            :Exceptions:
             - WebDriverException : Raised either when it can&amp;#39;t start the service
               or when it can&amp;#39;t connect to the service
            &amp;quot;&amp;quot;&amp;quot;
        try:
            cmd = [self.path]
            cmd.extend(self.command_line_args())
            self.process = subprocess.Popen(cmd, env=self.env,
                                            close_fds=platform.system() != &amp;#39;Windows&amp;#39;,
                                            stdout=self.log_file,
                                            stderr=self.log_file,
&amp;gt;                                           stdin=PIPE)
../venv/lib/python3.5/site-packages/selenium/webdriver/common/service.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = &amp;lt;subprocess.Popen object at 0x7fd15503b278&amp;gt;
args = [&amp;#39;geckodriver&amp;#39;, &amp;#39;--port&amp;#39;, &amp;#39;35421&amp;#39;], bufsize = -1, executable = None
stdin = -1
stdout = &amp;lt;_io.TextIOWrapper name=&amp;#39;geckodriver.log&amp;#39; mode=&amp;#39;a+&amp;#39; encoding=&amp;#39;UTF-8&amp;#39;&amp;gt;
stderr = &amp;lt;_io.TextIOWrapper name=&amp;#39;geckodriver.log&amp;#39; mode=&amp;#39;a+&amp;#39; encoding=&amp;#39;UTF-8&amp;#39;&amp;gt;
preexec_fn = None, close_fds = True, shell = False, cwd = None
env = environ({&amp;#39;PYTHONPATH&amp;#39;: &amp;#39;/home/sqa-user/Apps/pycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;GDM_LANG&amp;#39;: &amp;#39;en_US&amp;#39;, &amp;#39;XDG_SES...ycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;QT_ACCESSIBILITY&amp;#39;: &amp;#39;1&amp;#39;, &amp;#39;GNOME_DESKTOP_SESSION_ID&amp;#39;: &amp;#39;this-is-deprecated&amp;#39;})
universal_newlines = False, startupinfo = None, creationflags = 0
restore_signals = True, start_new_session = False, pass_fds = ()
    def __init__(self, args, bufsize=-1, executable=None,
                 stdin=None, stdout=None, stderr=None,
                 preexec_fn=None, close_fds=_PLATFORM_DEFAULT_CLOSE_FDS,
                 shell=False, cwd=None, env=None, universal_newlines=False,
                 startupinfo=None, creationflags=0,
                 restore_signals=True, start_new_session=False,
                 pass_fds=()):
        &amp;quot;&amp;quot;&amp;quot;Create new Popen instance.&amp;quot;&amp;quot;&amp;quot;
        _cleanup()
        # Held while anything is calling waitpid before returncode has been
        # updated to prevent clobbering returncode if wait() or poll() are
        # called from multiple threads at once.  After acquiring the lock,
        # code must re-check self.returncode to see if another thread just
        # finished a waitpid() call.
        self._waitpid_lock = threading.Lock()
    
        self._input = None
        self._communication_started = False
        if bufsize is None:
            bufsize = -1  # Restore default
        if not isinstance(bufsize, int):
            raise TypeError(&amp;quot;bufsize must be an integer&amp;quot;)
    
        if _mswindows:
            if preexec_fn is not None:
                raise ValueError(&amp;quot;preexec_fn is not supported on Windows &amp;quot;
                                 &amp;quot;platforms&amp;quot;)
            any_stdio_set = (stdin is not None or stdout is not None or
                             stderr is not None)
            if close_fds is _PLATFORM_DEFAULT_CLOSE_FDS:
                if any_stdio_set:
                    close_fds = False
                else:
                    close_fds = True
            elif close_fds and any_stdio_set:
                raise ValueError(
                        &amp;quot;close_fds is not supported on Windows platforms&amp;quot;
                        &amp;quot; if you redirect stdin/stdout/stderr&amp;quot;)
        else:
            # POSIX
            if close_fds is _PLATFORM_DEFAULT_CLOSE_FDS:
                close_fds = True
            if pass_fds and not close_fds:
                warnings.warn(&amp;quot;pass_fds overriding close_fds.&amp;quot;, RuntimeWarning)
                close_fds = True
            if startupinfo is not None:
                raise ValueError(&amp;quot;startupinfo is only supported on Windows &amp;quot;
                                 &amp;quot;platforms&amp;quot;)
            if creationflags != 0:
                raise ValueError(&amp;quot;creationflags is only supported on Windows &amp;quot;
                                 &amp;quot;platforms&amp;quot;)
    
        self.args = args
        self.stdin = None
        self.stdout = None
        self.stderr = None
        self.pid = None
        self.returncode = None
        self.universal_newlines = universal_newlines
    
        # Input and output objects. The general principle is like
        # this:
        #
        # Parent                   Child
        # ------                   -----
        # p2cwrite   ---stdin---&amp;gt;  p2cread
        # c2pread    &amp;lt;--stdout---  c2pwrite
        # errread    &amp;lt;--stderr---  errwrite
        #
        # On POSIX, the child objects are file descriptors.  On
        # Windows, these are Windows file handles.  The parent objects
        # are file descriptors on both platforms.  The parent objects
        # are -1 when not using PIPEs. The child objects are -1
        # when not redirecting.
    
        (p2cread, p2cwrite,
         c2pread, c2pwrite,
         errread, errwrite) = self._get_handles(stdin, stdout, stderr)
    
        # We wrap OS handles *before* launching the child, otherwise a
        # quickly terminating child could make our fds unwrappable
        # (see #8458).
    
        if _mswindows:
            if p2cwrite != -1:
                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)
            if c2pread != -1:
                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)
            if errread != -1:
                errread = msvcrt.open_osfhandle(errread.Detach(), 0)
    
        if p2cwrite != -1:
            self.stdin = io.open(p2cwrite, &amp;#39;wb&amp;#39;, bufsize)
            if universal_newlines:
                self.stdin = io.TextIOWrapper(self.stdin, write_through=True,
                                              line_buffering=(bufsize == 1))
        if c2pread != -1:
            self.stdout = io.open(c2pread, &amp;#39;rb&amp;#39;, bufsize)
            if universal_newlines:
                self.stdout = io.TextIOWrapper(self.stdout)
        if errread != -1:
            self.stderr = io.open(errread, &amp;#39;rb&amp;#39;, bufsize)
            if universal_newlines:
                self.stderr = io.TextIOWrapper(self.stderr)
    
        self._closed_child_pipe_fds = False
        try:
            self._execute_child(args, executable, preexec_fn, close_fds,
                                pass_fds, cwd, env,
                                startupinfo, creationflags, shell,
                                p2cread, p2cwrite,
                                c2pread, c2pwrite,
                                errread, errwrite,
&amp;gt;                               restore_signals, start_new_session)
/usr/lib/python3.5/subprocess.py:947: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = &amp;lt;subprocess.Popen object at 0x7fd15503b278&amp;gt;
args = [&amp;#39;geckodriver&amp;#39;, &amp;#39;--port&amp;#39;, &amp;#39;35421&amp;#39;], executable = b&amp;#39;geckodriver&amp;#39;
preexec_fn = None, close_fds = True, pass_fds = (), cwd = None
env = environ({&amp;#39;PYTHONPATH&amp;#39;: &amp;#39;/home/sqa-user/Apps/pycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;GDM_LANG&amp;#39;: &amp;#39;en_US&amp;#39;, &amp;#39;XDG_SES...ycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;QT_ACCESSIBILITY&amp;#39;: &amp;#39;1&amp;#39;, &amp;#39;GNOME_DESKTOP_SESSION_ID&amp;#39;: &amp;#39;this-is-deprecated&amp;#39;})
startupinfo = None, creationflags = 0, shell = False, p2cread = 10
p2cwrite = 11, c2pread = -1, c2pwrite = 8, errread = -1, errwrite = 8
restore_signals = True, start_new_session = False
    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals, start_new_session):
        &amp;quot;&amp;quot;&amp;quot;Execute program (POSIX version)&amp;quot;&amp;quot;&amp;quot;
    
        if isinstance(args, (str, bytes)):
            args = [args]
        else:
            args = list(args)
    
        if shell:
            args = [&amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: &amp;quot;exception name:hex errno:description&amp;quot;
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write &amp;lt; 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = [os.fsencode(k) + b&amp;#39;=&amp;#39; + os.fsencode(v)
                                for k, v in env.items()]
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, sorted(fds_to_keep), cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session, preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            # self._devnull is not always defined.
            devnull_fd = getattr(self, &amp;#39;_devnull&amp;#39;, None)
            if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                os.close(p2cread)
            if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                os.close(c2pwrite)
            if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                os.close(errwrite)
            if devnull_fd is not None:
                os.close(devnull_fd)
            # Prevent a double close of these fds from __init__ on error.
            self._closed_child_pipe_fds = True
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) &amp;gt; 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                os.waitpid(self.pid, 0)
            except ChildProcessError:
                pass
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b&amp;#39;:&amp;#39;, 2))
            except ValueError:
                exception_name = b&amp;#39;SubprocessError&amp;#39;
                hex_errno = b&amp;#39;0&amp;#39;
                err_msg = (b&amp;#39;Bad exception data from child: &amp;#39; +
                           repr(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode(&amp;#39;ascii&amp;#39;),
                    SubprocessError)
            err_msg = err_msg.decode(errors=&amp;quot;surrogatepass&amp;quot;)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == &amp;quot;noexec&amp;quot;)
                if child_exec_never_called:
                    err_msg = &amp;quot;&amp;quot;
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
                    if errno_num == errno.ENOENT:
                        if child_exec_never_called:
                            # The error must be from chdir(cwd).
                            err_msg += &amp;#39;: &amp;#39; + repr(cwd)
                        else:
                            err_msg += &amp;#39;: &amp;#39; + repr(orig_executable)
&amp;gt;               raise child_exception_type(errno_num, err_msg)
E               FileNotFoundError: [Errno 2] No such file or directory: &amp;#39;geckodriver&amp;#39;
/usr/lib/python3.5/subprocess.py:1551: FileNotFoundError
During handling of the above exception, another exception occurred:
request = &amp;lt;SubRequest &amp;#39;apl&amp;#39; for &amp;lt;Function &amp;#39;test_create_contact[None:::]&amp;#39;&amp;gt;&amp;gt;
    @pytest.fixture
    def apl(request):
        global fixture
        browser = request.config.getoption(&amp;quot;--browser&amp;quot;)
        web_config= load_config(request.config.getoption(&amp;quot;--target&amp;quot;))[&amp;quot;web&amp;quot;]
        if fixture is None or not fixture.is_valid():
&amp;gt;           fixture = Aplicant(browser=browser, base_url=web_config[&amp;quot;baseUrl&amp;quot;])
../conftest.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../fixture/aplicanter.py:12: in __init__
    self.wd = webdriver.Firefox()
../venv/lib/python3.5/site-packages/selenium/webdriver/firefox/webdriver.py:152: in __init__
    self.service.start()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = &amp;lt;selenium.webdriver.firefox.service.Service object at 0x7fd15503b080&amp;gt;
    def start(self):
        &amp;quot;&amp;quot;&amp;quot;
            Starts the Service.
    
            :Exceptions:
             - WebDriverException : Raised either when it can&amp;#39;t start the service
               or when it can&amp;#39;t connect to the service
            &amp;quot;&amp;quot;&amp;quot;
        try:
            cmd = [self.path]
            cmd.extend(self.command_line_args())
            self.process = subprocess.Popen(cmd, env=self.env,
                                            close_fds=platform.system() != &amp;#39;Windows&amp;#39;,
                                            stdout=self.log_file,
                                            stderr=self.log_file,
                                            stdin=PIPE)
        except TypeError:
            raise
        except OSError as err:
            if err.errno == errno.ENOENT:
                raise WebDriverException(
                    &amp;quot;&amp;#39;%s&amp;#39; executable needs to be in PATH. %s&amp;quot; % (
&amp;gt;                       os.path.basename(self.path), self.start_error_message)
E                       selenium.common.exceptions.WebDriverException: Message: &amp;#39;geckodriver&amp;#39; executable needs to be in PATH.
../venv/lib/python3.5/site-packages/selenium/webdriver/common/service.py:83: WebDriverException
</output>
            </test>
            <test duration="10" locationUrl="python&lt;/home/sqa-user/PycharmProjects/Python_for_testers/tests&gt;://test_create_contact.test_create_contact." name="(None:lastnamePtR :firstnamehyGgKFvk:addressaLYI5l)" status="failed">
                <output type="stdout">E
</output>
                <output type="stderr">test setup failed
self = &amp;lt;selenium.webdriver.firefox.service.Service object at 0x7fd15503bb70&amp;gt;
    def start(self):
        &amp;quot;&amp;quot;&amp;quot;
            Starts the Service.
    
            :Exceptions:
             - WebDriverException : Raised either when it can&amp;#39;t start the service
               or when it can&amp;#39;t connect to the service
            &amp;quot;&amp;quot;&amp;quot;
        try:
            cmd = [self.path]
            cmd.extend(self.command_line_args())
            self.process = subprocess.Popen(cmd, env=self.env,
                                            close_fds=platform.system() != &amp;#39;Windows&amp;#39;,
                                            stdout=self.log_file,
                                            stderr=self.log_file,
&amp;gt;                                           stdin=PIPE)
../venv/lib/python3.5/site-packages/selenium/webdriver/common/service.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = &amp;lt;subprocess.Popen object at 0x7fd154f36048&amp;gt;
args = [&amp;#39;geckodriver&amp;#39;, &amp;#39;--port&amp;#39;, &amp;#39;50121&amp;#39;], bufsize = -1, executable = None
stdin = -1
stdout = &amp;lt;_io.TextIOWrapper name=&amp;#39;geckodriver.log&amp;#39; mode=&amp;#39;a+&amp;#39; encoding=&amp;#39;UTF-8&amp;#39;&amp;gt;
stderr = &amp;lt;_io.TextIOWrapper name=&amp;#39;geckodriver.log&amp;#39; mode=&amp;#39;a+&amp;#39; encoding=&amp;#39;UTF-8&amp;#39;&amp;gt;
preexec_fn = None, close_fds = True, shell = False, cwd = None
env = environ({&amp;#39;PYTHONPATH&amp;#39;: &amp;#39;/home/sqa-user/Apps/pycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;GDM_LANG&amp;#39;: &amp;#39;en_US&amp;#39;, &amp;#39;XDG_SES...ycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;QT_ACCESSIBILITY&amp;#39;: &amp;#39;1&amp;#39;, &amp;#39;GNOME_DESKTOP_SESSION_ID&amp;#39;: &amp;#39;this-is-deprecated&amp;#39;})
universal_newlines = False, startupinfo = None, creationflags = 0
restore_signals = True, start_new_session = False, pass_fds = ()
    def __init__(self, args, bufsize=-1, executable=None,
                 stdin=None, stdout=None, stderr=None,
                 preexec_fn=None, close_fds=_PLATFORM_DEFAULT_CLOSE_FDS,
                 shell=False, cwd=None, env=None, universal_newlines=False,
                 startupinfo=None, creationflags=0,
                 restore_signals=True, start_new_session=False,
                 pass_fds=()):
        &amp;quot;&amp;quot;&amp;quot;Create new Popen instance.&amp;quot;&amp;quot;&amp;quot;
        _cleanup()
        # Held while anything is calling waitpid before returncode has been
        # updated to prevent clobbering returncode if wait() or poll() are
        # called from multiple threads at once.  After acquiring the lock,
        # code must re-check self.returncode to see if another thread just
        # finished a waitpid() call.
        self._waitpid_lock = threading.Lock()
    
        self._input = None
        self._communication_started = False
        if bufsize is None:
            bufsize = -1  # Restore default
        if not isinstance(bufsize, int):
            raise TypeError(&amp;quot;bufsize must be an integer&amp;quot;)
    
        if _mswindows:
            if preexec_fn is not None:
                raise ValueError(&amp;quot;preexec_fn is not supported on Windows &amp;quot;
                                 &amp;quot;platforms&amp;quot;)
            any_stdio_set = (stdin is not None or stdout is not None or
                             stderr is not None)
            if close_fds is _PLATFORM_DEFAULT_CLOSE_FDS:
                if any_stdio_set:
                    close_fds = False
                else:
                    close_fds = True
            elif close_fds and any_stdio_set:
                raise ValueError(
                        &amp;quot;close_fds is not supported on Windows platforms&amp;quot;
                        &amp;quot; if you redirect stdin/stdout/stderr&amp;quot;)
        else:
            # POSIX
            if close_fds is _PLATFORM_DEFAULT_CLOSE_FDS:
                close_fds = True
            if pass_fds and not close_fds:
                warnings.warn(&amp;quot;pass_fds overriding close_fds.&amp;quot;, RuntimeWarning)
                close_fds = True
            if startupinfo is not None:
                raise ValueError(&amp;quot;startupinfo is only supported on Windows &amp;quot;
                                 &amp;quot;platforms&amp;quot;)
            if creationflags != 0:
                raise ValueError(&amp;quot;creationflags is only supported on Windows &amp;quot;
                                 &amp;quot;platforms&amp;quot;)
    
        self.args = args
        self.stdin = None
        self.stdout = None
        self.stderr = None
        self.pid = None
        self.returncode = None
        self.universal_newlines = universal_newlines
    
        # Input and output objects. The general principle is like
        # this:
        #
        # Parent                   Child
        # ------                   -----
        # p2cwrite   ---stdin---&amp;gt;  p2cread
        # c2pread    &amp;lt;--stdout---  c2pwrite
        # errread    &amp;lt;--stderr---  errwrite
        #
        # On POSIX, the child objects are file descriptors.  On
        # Windows, these are Windows file handles.  The parent objects
        # are file descriptors on both platforms.  The parent objects
        # are -1 when not using PIPEs. The child objects are -1
        # when not redirecting.
    
        (p2cread, p2cwrite,
         c2pread, c2pwrite,
         errread, errwrite) = self._get_handles(stdin, stdout, stderr)
    
        # We wrap OS handles *before* launching the child, otherwise a
        # quickly terminating child could make our fds unwrappable
        # (see #8458).
    
        if _mswindows:
            if p2cwrite != -1:
                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)
            if c2pread != -1:
                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)
            if errread != -1:
                errread = msvcrt.open_osfhandle(errread.Detach(), 0)
    
        if p2cwrite != -1:
            self.stdin = io.open(p2cwrite, &amp;#39;wb&amp;#39;, bufsize)
            if universal_newlines:
                self.stdin = io.TextIOWrapper(self.stdin, write_through=True,
                                              line_buffering=(bufsize == 1))
        if c2pread != -1:
            self.stdout = io.open(c2pread, &amp;#39;rb&amp;#39;, bufsize)
            if universal_newlines:
                self.stdout = io.TextIOWrapper(self.stdout)
        if errread != -1:
            self.stderr = io.open(errread, &amp;#39;rb&amp;#39;, bufsize)
            if universal_newlines:
                self.stderr = io.TextIOWrapper(self.stderr)
    
        self._closed_child_pipe_fds = False
        try:
            self._execute_child(args, executable, preexec_fn, close_fds,
                                pass_fds, cwd, env,
                                startupinfo, creationflags, shell,
                                p2cread, p2cwrite,
                                c2pread, c2pwrite,
                                errread, errwrite,
&amp;gt;                               restore_signals, start_new_session)
/usr/lib/python3.5/subprocess.py:947: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = &amp;lt;subprocess.Popen object at 0x7fd154f36048&amp;gt;
args = [&amp;#39;geckodriver&amp;#39;, &amp;#39;--port&amp;#39;, &amp;#39;50121&amp;#39;], executable = b&amp;#39;geckodriver&amp;#39;
preexec_fn = None, close_fds = True, pass_fds = (), cwd = None
env = environ({&amp;#39;PYTHONPATH&amp;#39;: &amp;#39;/home/sqa-user/Apps/pycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;GDM_LANG&amp;#39;: &amp;#39;en_US&amp;#39;, &amp;#39;XDG_SES...ycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;QT_ACCESSIBILITY&amp;#39;: &amp;#39;1&amp;#39;, &amp;#39;GNOME_DESKTOP_SESSION_ID&amp;#39;: &amp;#39;this-is-deprecated&amp;#39;})
startupinfo = None, creationflags = 0, shell = False, p2cread = 11
p2cwrite = 12, c2pread = -1, c2pwrite = 10, errread = -1, errwrite = 10
restore_signals = True, start_new_session = False
    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals, start_new_session):
        &amp;quot;&amp;quot;&amp;quot;Execute program (POSIX version)&amp;quot;&amp;quot;&amp;quot;
    
        if isinstance(args, (str, bytes)):
            args = [args]
        else:
            args = list(args)
    
        if shell:
            args = [&amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: &amp;quot;exception name:hex errno:description&amp;quot;
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write &amp;lt; 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = [os.fsencode(k) + b&amp;#39;=&amp;#39; + os.fsencode(v)
                                for k, v in env.items()]
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, sorted(fds_to_keep), cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session, preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            # self._devnull is not always defined.
            devnull_fd = getattr(self, &amp;#39;_devnull&amp;#39;, None)
            if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                os.close(p2cread)
            if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                os.close(c2pwrite)
            if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                os.close(errwrite)
            if devnull_fd is not None:
                os.close(devnull_fd)
            # Prevent a double close of these fds from __init__ on error.
            self._closed_child_pipe_fds = True
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) &amp;gt; 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                os.waitpid(self.pid, 0)
            except ChildProcessError:
                pass
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b&amp;#39;:&amp;#39;, 2))
            except ValueError:
                exception_name = b&amp;#39;SubprocessError&amp;#39;
                hex_errno = b&amp;#39;0&amp;#39;
                err_msg = (b&amp;#39;Bad exception data from child: &amp;#39; +
                           repr(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode(&amp;#39;ascii&amp;#39;),
                    SubprocessError)
            err_msg = err_msg.decode(errors=&amp;quot;surrogatepass&amp;quot;)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == &amp;quot;noexec&amp;quot;)
                if child_exec_never_called:
                    err_msg = &amp;quot;&amp;quot;
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
                    if errno_num == errno.ENOENT:
                        if child_exec_never_called:
                            # The error must be from chdir(cwd).
                            err_msg += &amp;#39;: &amp;#39; + repr(cwd)
                        else:
                            err_msg += &amp;#39;: &amp;#39; + repr(orig_executable)
&amp;gt;               raise child_exception_type(errno_num, err_msg)
E               FileNotFoundError: [Errno 2] No such file or directory: &amp;#39;geckodriver&amp;#39;
/usr/lib/python3.5/subprocess.py:1551: FileNotFoundError
During handling of the above exception, another exception occurred:
request = &amp;lt;SubRequest &amp;#39;apl&amp;#39; for &amp;lt;Function &amp;#39;test_create_contact[None:lastnamePtR :firstnamehyGgKFvk:addressaLYI5l]&amp;#39;&amp;gt;&amp;gt;
    @pytest.fixture
    def apl(request):
        global fixture
        browser = request.config.getoption(&amp;quot;--browser&amp;quot;)
        web_config= load_config(request.config.getoption(&amp;quot;--target&amp;quot;))[&amp;quot;web&amp;quot;]
        if fixture is None or not fixture.is_valid():
&amp;gt;           fixture = Aplicant(browser=browser, base_url=web_config[&amp;quot;baseUrl&amp;quot;])
../conftest.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../fixture/aplicanter.py:12: in __init__
    self.wd = webdriver.Firefox()
../venv/lib/python3.5/site-packages/selenium/webdriver/firefox/webdriver.py:152: in __init__
    self.service.start()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = &amp;lt;selenium.webdriver.firefox.service.Service object at 0x7fd15503bb70&amp;gt;
    def start(self):
        &amp;quot;&amp;quot;&amp;quot;
            Starts the Service.
    
            :Exceptions:
             - WebDriverException : Raised either when it can&amp;#39;t start the service
               or when it can&amp;#39;t connect to the service
            &amp;quot;&amp;quot;&amp;quot;
        try:
            cmd = [self.path]
            cmd.extend(self.command_line_args())
            self.process = subprocess.Popen(cmd, env=self.env,
                                            close_fds=platform.system() != &amp;#39;Windows&amp;#39;,
                                            stdout=self.log_file,
                                            stderr=self.log_file,
                                            stdin=PIPE)
        except TypeError:
            raise
        except OSError as err:
            if err.errno == errno.ENOENT:
                raise WebDriverException(
                    &amp;quot;&amp;#39;%s&amp;#39; executable needs to be in PATH. %s&amp;quot; % (
&amp;gt;                       os.path.basename(self.path), self.start_error_message)
E                       selenium.common.exceptions.WebDriverException: Message: &amp;#39;geckodriver&amp;#39; executable needs to be in PATH.
../venv/lib/python3.5/site-packages/selenium/webdriver/common/service.py:83: WebDriverException
</output>
            </test>
            <test duration="7" locationUrl="python&lt;/home/sqa-user/PycharmProjects/Python_for_testers/tests&gt;://test_create_contact.test_create_contact." name="(None:lastname jLceqo:firstname i :address dXIK2s9ZP2RK9752B  eGS nrtj oI 7Tvjj4PgkZQgk0v0)" status="failed">
                <output type="stdout">E
</output>
                <output type="stderr">test setup failed
self = &amp;lt;selenium.webdriver.firefox.service.Service object at 0x7fd154f5e978&amp;gt;
    def start(self):
        &amp;quot;&amp;quot;&amp;quot;
            Starts the Service.
    
            :Exceptions:
             - WebDriverException : Raised either when it can&amp;#39;t start the service
               or when it can&amp;#39;t connect to the service
            &amp;quot;&amp;quot;&amp;quot;
        try:
            cmd = [self.path]
            cmd.extend(self.command_line_args())
            self.process = subprocess.Popen(cmd, env=self.env,
                                            close_fds=platform.system() != &amp;#39;Windows&amp;#39;,
                                            stdout=self.log_file,
                                            stderr=self.log_file,
&amp;gt;                                           stdin=PIPE)
../venv/lib/python3.5/site-packages/selenium/webdriver/common/service.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = &amp;lt;subprocess.Popen object at 0x7fd154f5eba8&amp;gt;
args = [&amp;#39;geckodriver&amp;#39;, &amp;#39;--port&amp;#39;, &amp;#39;52641&amp;#39;], bufsize = -1, executable = None
stdin = -1
stdout = &amp;lt;_io.TextIOWrapper name=&amp;#39;geckodriver.log&amp;#39; mode=&amp;#39;a+&amp;#39; encoding=&amp;#39;UTF-8&amp;#39;&amp;gt;
stderr = &amp;lt;_io.TextIOWrapper name=&amp;#39;geckodriver.log&amp;#39; mode=&amp;#39;a+&amp;#39; encoding=&amp;#39;UTF-8&amp;#39;&amp;gt;
preexec_fn = None, close_fds = True, shell = False, cwd = None
env = environ({&amp;#39;PYTHONPATH&amp;#39;: &amp;#39;/home/sqa-user/Apps/pycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;GDM_LANG&amp;#39;: &amp;#39;en_US&amp;#39;, &amp;#39;XDG_SES...ycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;QT_ACCESSIBILITY&amp;#39;: &amp;#39;1&amp;#39;, &amp;#39;GNOME_DESKTOP_SESSION_ID&amp;#39;: &amp;#39;this-is-deprecated&amp;#39;})
universal_newlines = False, startupinfo = None, creationflags = 0
restore_signals = True, start_new_session = False, pass_fds = ()
    def __init__(self, args, bufsize=-1, executable=None,
                 stdin=None, stdout=None, stderr=None,
                 preexec_fn=None, close_fds=_PLATFORM_DEFAULT_CLOSE_FDS,
                 shell=False, cwd=None, env=None, universal_newlines=False,
                 startupinfo=None, creationflags=0,
                 restore_signals=True, start_new_session=False,
                 pass_fds=()):
        &amp;quot;&amp;quot;&amp;quot;Create new Popen instance.&amp;quot;&amp;quot;&amp;quot;
        _cleanup()
        # Held while anything is calling waitpid before returncode has been
        # updated to prevent clobbering returncode if wait() or poll() are
        # called from multiple threads at once.  After acquiring the lock,
        # code must re-check self.returncode to see if another thread just
        # finished a waitpid() call.
        self._waitpid_lock = threading.Lock()
    
        self._input = None
        self._communication_started = False
        if bufsize is None:
            bufsize = -1  # Restore default
        if not isinstance(bufsize, int):
            raise TypeError(&amp;quot;bufsize must be an integer&amp;quot;)
    
        if _mswindows:
            if preexec_fn is not None:
                raise ValueError(&amp;quot;preexec_fn is not supported on Windows &amp;quot;
                                 &amp;quot;platforms&amp;quot;)
            any_stdio_set = (stdin is not None or stdout is not None or
                             stderr is not None)
            if close_fds is _PLATFORM_DEFAULT_CLOSE_FDS:
                if any_stdio_set:
                    close_fds = False
                else:
                    close_fds = True
            elif close_fds and any_stdio_set:
                raise ValueError(
                        &amp;quot;close_fds is not supported on Windows platforms&amp;quot;
                        &amp;quot; if you redirect stdin/stdout/stderr&amp;quot;)
        else:
            # POSIX
            if close_fds is _PLATFORM_DEFAULT_CLOSE_FDS:
                close_fds = True
            if pass_fds and not close_fds:
                warnings.warn(&amp;quot;pass_fds overriding close_fds.&amp;quot;, RuntimeWarning)
                close_fds = True
            if startupinfo is not None:
                raise ValueError(&amp;quot;startupinfo is only supported on Windows &amp;quot;
                                 &amp;quot;platforms&amp;quot;)
            if creationflags != 0:
                raise ValueError(&amp;quot;creationflags is only supported on Windows &amp;quot;
                                 &amp;quot;platforms&amp;quot;)
    
        self.args = args
        self.stdin = None
        self.stdout = None
        self.stderr = None
        self.pid = None
        self.returncode = None
        self.universal_newlines = universal_newlines
    
        # Input and output objects. The general principle is like
        # this:
        #
        # Parent                   Child
        # ------                   -----
        # p2cwrite   ---stdin---&amp;gt;  p2cread
        # c2pread    &amp;lt;--stdout---  c2pwrite
        # errread    &amp;lt;--stderr---  errwrite
        #
        # On POSIX, the child objects are file descriptors.  On
        # Windows, these are Windows file handles.  The parent objects
        # are file descriptors on both platforms.  The parent objects
        # are -1 when not using PIPEs. The child objects are -1
        # when not redirecting.
    
        (p2cread, p2cwrite,
         c2pread, c2pwrite,
         errread, errwrite) = self._get_handles(stdin, stdout, stderr)
    
        # We wrap OS handles *before* launching the child, otherwise a
        # quickly terminating child could make our fds unwrappable
        # (see #8458).
    
        if _mswindows:
            if p2cwrite != -1:
                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)
            if c2pread != -1:
                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)
            if errread != -1:
                errread = msvcrt.open_osfhandle(errread.Detach(), 0)
    
        if p2cwrite != -1:
            self.stdin = io.open(p2cwrite, &amp;#39;wb&amp;#39;, bufsize)
            if universal_newlines:
                self.stdin = io.TextIOWrapper(self.stdin, write_through=True,
                                              line_buffering=(bufsize == 1))
        if c2pread != -1:
            self.stdout = io.open(c2pread, &amp;#39;rb&amp;#39;, bufsize)
            if universal_newlines:
                self.stdout = io.TextIOWrapper(self.stdout)
        if errread != -1:
            self.stderr = io.open(errread, &amp;#39;rb&amp;#39;, bufsize)
            if universal_newlines:
                self.stderr = io.TextIOWrapper(self.stderr)
    
        self._closed_child_pipe_fds = False
        try:
            self._execute_child(args, executable, preexec_fn, close_fds,
                                pass_fds, cwd, env,
                                startupinfo, creationflags, shell,
                                p2cread, p2cwrite,
                                c2pread, c2pwrite,
                                errread, errwrite,
&amp;gt;                               restore_signals, start_new_session)
/usr/lib/python3.5/subprocess.py:947: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = &amp;lt;subprocess.Popen object at 0x7fd154f5eba8&amp;gt;
args = [&amp;#39;geckodriver&amp;#39;, &amp;#39;--port&amp;#39;, &amp;#39;52641&amp;#39;], executable = b&amp;#39;geckodriver&amp;#39;
preexec_fn = None, close_fds = True, pass_fds = (), cwd = None
env = environ({&amp;#39;PYTHONPATH&amp;#39;: &amp;#39;/home/sqa-user/Apps/pycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;GDM_LANG&amp;#39;: &amp;#39;en_US&amp;#39;, &amp;#39;XDG_SES...ycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;QT_ACCESSIBILITY&amp;#39;: &amp;#39;1&amp;#39;, &amp;#39;GNOME_DESKTOP_SESSION_ID&amp;#39;: &amp;#39;this-is-deprecated&amp;#39;})
startupinfo = None, creationflags = 0, shell = False, p2cread = 12
p2cwrite = 13, c2pread = -1, c2pwrite = 11, errread = -1, errwrite = 11
restore_signals = True, start_new_session = False
    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals, start_new_session):
        &amp;quot;&amp;quot;&amp;quot;Execute program (POSIX version)&amp;quot;&amp;quot;&amp;quot;
    
        if isinstance(args, (str, bytes)):
            args = [args]
        else:
            args = list(args)
    
        if shell:
            args = [&amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: &amp;quot;exception name:hex errno:description&amp;quot;
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write &amp;lt; 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = [os.fsencode(k) + b&amp;#39;=&amp;#39; + os.fsencode(v)
                                for k, v in env.items()]
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, sorted(fds_to_keep), cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session, preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            # self._devnull is not always defined.
            devnull_fd = getattr(self, &amp;#39;_devnull&amp;#39;, None)
            if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                os.close(p2cread)
            if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                os.close(c2pwrite)
            if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                os.close(errwrite)
            if devnull_fd is not None:
                os.close(devnull_fd)
            # Prevent a double close of these fds from __init__ on error.
            self._closed_child_pipe_fds = True
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) &amp;gt; 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                os.waitpid(self.pid, 0)
            except ChildProcessError:
                pass
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b&amp;#39;:&amp;#39;, 2))
            except ValueError:
                exception_name = b&amp;#39;SubprocessError&amp;#39;
                hex_errno = b&amp;#39;0&amp;#39;
                err_msg = (b&amp;#39;Bad exception data from child: &amp;#39; +
                           repr(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode(&amp;#39;ascii&amp;#39;),
                    SubprocessError)
            err_msg = err_msg.decode(errors=&amp;quot;surrogatepass&amp;quot;)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == &amp;quot;noexec&amp;quot;)
                if child_exec_never_called:
                    err_msg = &amp;quot;&amp;quot;
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
                    if errno_num == errno.ENOENT:
                        if child_exec_never_called:
                            # The error must be from chdir(cwd).
                            err_msg += &amp;#39;: &amp;#39; + repr(cwd)
                        else:
                            err_msg += &amp;#39;: &amp;#39; + repr(orig_executable)
&amp;gt;               raise child_exception_type(errno_num, err_msg)
E               FileNotFoundError: [Errno 2] No such file or directory: &amp;#39;geckodriver&amp;#39;
/usr/lib/python3.5/subprocess.py:1551: FileNotFoundError
During handling of the above exception, another exception occurred:
request = &amp;lt;SubRequest &amp;#39;apl&amp;#39; for &amp;lt;Function &amp;#39;test_create_contact[None:lastname jLceqo:firstname i :address dXIK2s9ZP2RK9752B  eGS nrtj oI 7Tvjj4PgkZQgk0v0]&amp;#39;&amp;gt;&amp;gt;
    @pytest.fixture
    def apl(request):
        global fixture
        browser = request.config.getoption(&amp;quot;--browser&amp;quot;)
        web_config= load_config(request.config.getoption(&amp;quot;--target&amp;quot;))[&amp;quot;web&amp;quot;]
        if fixture is None or not fixture.is_valid():
&amp;gt;           fixture = Aplicant(browser=browser, base_url=web_config[&amp;quot;baseUrl&amp;quot;])
../conftest.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../fixture/aplicanter.py:12: in __init__
    self.wd = webdriver.Firefox()
../venv/lib/python3.5/site-packages/selenium/webdriver/firefox/webdriver.py:152: in __init__
    self.service.start()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = &amp;lt;selenium.webdriver.firefox.service.Service object at 0x7fd154f5e978&amp;gt;
    def start(self):
        &amp;quot;&amp;quot;&amp;quot;
            Starts the Service.
    
            :Exceptions:
             - WebDriverException : Raised either when it can&amp;#39;t start the service
               or when it can&amp;#39;t connect to the service
            &amp;quot;&amp;quot;&amp;quot;
        try:
            cmd = [self.path]
            cmd.extend(self.command_line_args())
            self.process = subprocess.Popen(cmd, env=self.env,
                                            close_fds=platform.system() != &amp;#39;Windows&amp;#39;,
                                            stdout=self.log_file,
                                            stderr=self.log_file,
                                            stdin=PIPE)
        except TypeError:
            raise
        except OSError as err:
            if err.errno == errno.ENOENT:
                raise WebDriverException(
                    &amp;quot;&amp;#39;%s&amp;#39; executable needs to be in PATH. %s&amp;quot; % (
&amp;gt;                       os.path.basename(self.path), self.start_error_message)
E                       selenium.common.exceptions.WebDriverException: Message: &amp;#39;geckodriver&amp;#39; executable needs to be in PATH.
../venv/lib/python3.5/site-packages/selenium/webdriver/common/service.py:83: WebDriverException
</output>
            </test>
            <test duration="8" locationUrl="python&lt;/home/sqa-user/PycharmProjects/Python_for_testers/tests&gt;://test_create_contact.test_create_contact." name="(None:lastnamerMvMTpmEAE:firstname  GQMFjOlgd:address 4rWFC BY09Fa25rjP)" status="failed">
                <output type="stdout">E
</output>
                <output type="stderr">test setup failed
self = &amp;lt;selenium.webdriver.firefox.service.Service object at 0x7fd154f7b438&amp;gt;
    def start(self):
        &amp;quot;&amp;quot;&amp;quot;
            Starts the Service.
    
            :Exceptions:
             - WebDriverException : Raised either when it can&amp;#39;t start the service
               or when it can&amp;#39;t connect to the service
            &amp;quot;&amp;quot;&amp;quot;
        try:
            cmd = [self.path]
            cmd.extend(self.command_line_args())
            self.process = subprocess.Popen(cmd, env=self.env,
                                            close_fds=platform.system() != &amp;#39;Windows&amp;#39;,
                                            stdout=self.log_file,
                                            stderr=self.log_file,
&amp;gt;                                           stdin=PIPE)
../venv/lib/python3.5/site-packages/selenium/webdriver/common/service.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = &amp;lt;subprocess.Popen object at 0x7fd154e7ea58&amp;gt;
args = [&amp;#39;geckodriver&amp;#39;, &amp;#39;--port&amp;#39;, &amp;#39;38229&amp;#39;], bufsize = -1, executable = None
stdin = -1
stdout = &amp;lt;_io.TextIOWrapper name=&amp;#39;geckodriver.log&amp;#39; mode=&amp;#39;a+&amp;#39; encoding=&amp;#39;UTF-8&amp;#39;&amp;gt;
stderr = &amp;lt;_io.TextIOWrapper name=&amp;#39;geckodriver.log&amp;#39; mode=&amp;#39;a+&amp;#39; encoding=&amp;#39;UTF-8&amp;#39;&amp;gt;
preexec_fn = None, close_fds = True, shell = False, cwd = None
env = environ({&amp;#39;PYTHONPATH&amp;#39;: &amp;#39;/home/sqa-user/Apps/pycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;GDM_LANG&amp;#39;: &amp;#39;en_US&amp;#39;, &amp;#39;XDG_SES...ycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;QT_ACCESSIBILITY&amp;#39;: &amp;#39;1&amp;#39;, &amp;#39;GNOME_DESKTOP_SESSION_ID&amp;#39;: &amp;#39;this-is-deprecated&amp;#39;})
universal_newlines = False, startupinfo = None, creationflags = 0
restore_signals = True, start_new_session = False, pass_fds = ()
    def __init__(self, args, bufsize=-1, executable=None,
                 stdin=None, stdout=None, stderr=None,
                 preexec_fn=None, close_fds=_PLATFORM_DEFAULT_CLOSE_FDS,
                 shell=False, cwd=None, env=None, universal_newlines=False,
                 startupinfo=None, creationflags=0,
                 restore_signals=True, start_new_session=False,
                 pass_fds=()):
        &amp;quot;&amp;quot;&amp;quot;Create new Popen instance.&amp;quot;&amp;quot;&amp;quot;
        _cleanup()
        # Held while anything is calling waitpid before returncode has been
        # updated to prevent clobbering returncode if wait() or poll() are
        # called from multiple threads at once.  After acquiring the lock,
        # code must re-check self.returncode to see if another thread just
        # finished a waitpid() call.
        self._waitpid_lock = threading.Lock()
    
        self._input = None
        self._communication_started = False
        if bufsize is None:
            bufsize = -1  # Restore default
        if not isinstance(bufsize, int):
            raise TypeError(&amp;quot;bufsize must be an integer&amp;quot;)
    
        if _mswindows:
            if preexec_fn is not None:
                raise ValueError(&amp;quot;preexec_fn is not supported on Windows &amp;quot;
                                 &amp;quot;platforms&amp;quot;)
            any_stdio_set = (stdin is not None or stdout is not None or
                             stderr is not None)
            if close_fds is _PLATFORM_DEFAULT_CLOSE_FDS:
                if any_stdio_set:
                    close_fds = False
                else:
                    close_fds = True
            elif close_fds and any_stdio_set:
                raise ValueError(
                        &amp;quot;close_fds is not supported on Windows platforms&amp;quot;
                        &amp;quot; if you redirect stdin/stdout/stderr&amp;quot;)
        else:
            # POSIX
            if close_fds is _PLATFORM_DEFAULT_CLOSE_FDS:
                close_fds = True
            if pass_fds and not close_fds:
                warnings.warn(&amp;quot;pass_fds overriding close_fds.&amp;quot;, RuntimeWarning)
                close_fds = True
            if startupinfo is not None:
                raise ValueError(&amp;quot;startupinfo is only supported on Windows &amp;quot;
                                 &amp;quot;platforms&amp;quot;)
            if creationflags != 0:
                raise ValueError(&amp;quot;creationflags is only supported on Windows &amp;quot;
                                 &amp;quot;platforms&amp;quot;)
    
        self.args = args
        self.stdin = None
        self.stdout = None
        self.stderr = None
        self.pid = None
        self.returncode = None
        self.universal_newlines = universal_newlines
    
        # Input and output objects. The general principle is like
        # this:
        #
        # Parent                   Child
        # ------                   -----
        # p2cwrite   ---stdin---&amp;gt;  p2cread
        # c2pread    &amp;lt;--stdout---  c2pwrite
        # errread    &amp;lt;--stderr---  errwrite
        #
        # On POSIX, the child objects are file descriptors.  On
        # Windows, these are Windows file handles.  The parent objects
        # are file descriptors on both platforms.  The parent objects
        # are -1 when not using PIPEs. The child objects are -1
        # when not redirecting.
    
        (p2cread, p2cwrite,
         c2pread, c2pwrite,
         errread, errwrite) = self._get_handles(stdin, stdout, stderr)
    
        # We wrap OS handles *before* launching the child, otherwise a
        # quickly terminating child could make our fds unwrappable
        # (see #8458).
    
        if _mswindows:
            if p2cwrite != -1:
                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)
            if c2pread != -1:
                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)
            if errread != -1:
                errread = msvcrt.open_osfhandle(errread.Detach(), 0)
    
        if p2cwrite != -1:
            self.stdin = io.open(p2cwrite, &amp;#39;wb&amp;#39;, bufsize)
            if universal_newlines:
                self.stdin = io.TextIOWrapper(self.stdin, write_through=True,
                                              line_buffering=(bufsize == 1))
        if c2pread != -1:
            self.stdout = io.open(c2pread, &amp;#39;rb&amp;#39;, bufsize)
            if universal_newlines:
                self.stdout = io.TextIOWrapper(self.stdout)
        if errread != -1:
            self.stderr = io.open(errread, &amp;#39;rb&amp;#39;, bufsize)
            if universal_newlines:
                self.stderr = io.TextIOWrapper(self.stderr)
    
        self._closed_child_pipe_fds = False
        try:
            self._execute_child(args, executable, preexec_fn, close_fds,
                                pass_fds, cwd, env,
                                startupinfo, creationflags, shell,
                                p2cread, p2cwrite,
                                c2pread, c2pwrite,
                                errread, errwrite,
&amp;gt;                               restore_signals, start_new_session)
/usr/lib/python3.5/subprocess.py:947: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = &amp;lt;subprocess.Popen object at 0x7fd154e7ea58&amp;gt;
args = [&amp;#39;geckodriver&amp;#39;, &amp;#39;--port&amp;#39;, &amp;#39;38229&amp;#39;], executable = b&amp;#39;geckodriver&amp;#39;
preexec_fn = None, close_fds = True, pass_fds = (), cwd = None
env = environ({&amp;#39;PYTHONPATH&amp;#39;: &amp;#39;/home/sqa-user/Apps/pycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;GDM_LANG&amp;#39;: &amp;#39;en_US&amp;#39;, &amp;#39;XDG_SES...ycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;QT_ACCESSIBILITY&amp;#39;: &amp;#39;1&amp;#39;, &amp;#39;GNOME_DESKTOP_SESSION_ID&amp;#39;: &amp;#39;this-is-deprecated&amp;#39;})
startupinfo = None, creationflags = 0, shell = False, p2cread = 13
p2cwrite = 14, c2pread = -1, c2pwrite = 12, errread = -1, errwrite = 12
restore_signals = True, start_new_session = False
    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals, start_new_session):
        &amp;quot;&amp;quot;&amp;quot;Execute program (POSIX version)&amp;quot;&amp;quot;&amp;quot;
    
        if isinstance(args, (str, bytes)):
            args = [args]
        else:
            args = list(args)
    
        if shell:
            args = [&amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: &amp;quot;exception name:hex errno:description&amp;quot;
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write &amp;lt; 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = [os.fsencode(k) + b&amp;#39;=&amp;#39; + os.fsencode(v)
                                for k, v in env.items()]
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, sorted(fds_to_keep), cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session, preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            # self._devnull is not always defined.
            devnull_fd = getattr(self, &amp;#39;_devnull&amp;#39;, None)
            if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                os.close(p2cread)
            if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                os.close(c2pwrite)
            if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                os.close(errwrite)
            if devnull_fd is not None:
                os.close(devnull_fd)
            # Prevent a double close of these fds from __init__ on error.
            self._closed_child_pipe_fds = True
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) &amp;gt; 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                os.waitpid(self.pid, 0)
            except ChildProcessError:
                pass
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b&amp;#39;:&amp;#39;, 2))
            except ValueError:
                exception_name = b&amp;#39;SubprocessError&amp;#39;
                hex_errno = b&amp;#39;0&amp;#39;
                err_msg = (b&amp;#39;Bad exception data from child: &amp;#39; +
                           repr(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode(&amp;#39;ascii&amp;#39;),
                    SubprocessError)
            err_msg = err_msg.decode(errors=&amp;quot;surrogatepass&amp;quot;)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == &amp;quot;noexec&amp;quot;)
                if child_exec_never_called:
                    err_msg = &amp;quot;&amp;quot;
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
                    if errno_num == errno.ENOENT:
                        if child_exec_never_called:
                            # The error must be from chdir(cwd).
                            err_msg += &amp;#39;: &amp;#39; + repr(cwd)
                        else:
                            err_msg += &amp;#39;: &amp;#39; + repr(orig_executable)
&amp;gt;               raise child_exception_type(errno_num, err_msg)
E               FileNotFoundError: [Errno 2] No such file or directory: &amp;#39;geckodriver&amp;#39;
/usr/lib/python3.5/subprocess.py:1551: FileNotFoundError
During handling of the above exception, another exception occurred:
request = &amp;lt;SubRequest &amp;#39;apl&amp;#39; for &amp;lt;Function &amp;#39;test_create_contact[None:lastnamerMvMTpmEAE:firstname  GQMFjOlgd:address 4rWFC BY09Fa25rjP]&amp;#39;&amp;gt;&amp;gt;
    @pytest.fixture
    def apl(request):
        global fixture
        browser = request.config.getoption(&amp;quot;--browser&amp;quot;)
        web_config= load_config(request.config.getoption(&amp;quot;--target&amp;quot;))[&amp;quot;web&amp;quot;]
        if fixture is None or not fixture.is_valid():
&amp;gt;           fixture = Aplicant(browser=browser, base_url=web_config[&amp;quot;baseUrl&amp;quot;])
../conftest.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../fixture/aplicanter.py:12: in __init__
    self.wd = webdriver.Firefox()
../venv/lib/python3.5/site-packages/selenium/webdriver/firefox/webdriver.py:152: in __init__
    self.service.start()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = &amp;lt;selenium.webdriver.firefox.service.Service object at 0x7fd154f7b438&amp;gt;
    def start(self):
        &amp;quot;&amp;quot;&amp;quot;
            Starts the Service.
    
            :Exceptions:
             - WebDriverException : Raised either when it can&amp;#39;t start the service
               or when it can&amp;#39;t connect to the service
            &amp;quot;&amp;quot;&amp;quot;
        try:
            cmd = [self.path]
            cmd.extend(self.command_line_args())
            self.process = subprocess.Popen(cmd, env=self.env,
                                            close_fds=platform.system() != &amp;#39;Windows&amp;#39;,
                                            stdout=self.log_file,
                                            stderr=self.log_file,
                                            stdin=PIPE)
        except TypeError:
            raise
        except OSError as err:
            if err.errno == errno.ENOENT:
                raise WebDriverException(
                    &amp;quot;&amp;#39;%s&amp;#39; executable needs to be in PATH. %s&amp;quot; % (
&amp;gt;                       os.path.basename(self.path), self.start_error_message)
E                       selenium.common.exceptions.WebDriverException: Message: &amp;#39;geckodriver&amp;#39; executable needs to be in PATH.
../venv/lib/python3.5/site-packages/selenium/webdriver/common/service.py:83: WebDriverException
</output>
            </test>
            <test duration="7" locationUrl="python&lt;/home/sqa-user/PycharmProjects/Python_for_testers/tests&gt;://test_create_contact.test_create_contact." name="(None:lastnameOVeqDC:firstnameeRUcgTidXuC:address  _9TM dLMpKBi Z576eyiY9yiI9)" status="failed">
                <output type="stdout">E
</output>
                <output type="stderr">test setup failed
self = &amp;lt;selenium.webdriver.firefox.service.Service object at 0x7fd154fdf7f0&amp;gt;
    def start(self):
        &amp;quot;&amp;quot;&amp;quot;
            Starts the Service.
    
            :Exceptions:
             - WebDriverException : Raised either when it can&amp;#39;t start the service
               or when it can&amp;#39;t connect to the service
            &amp;quot;&amp;quot;&amp;quot;
        try:
            cmd = [self.path]
            cmd.extend(self.command_line_args())
            self.process = subprocess.Popen(cmd, env=self.env,
                                            close_fds=platform.system() != &amp;#39;Windows&amp;#39;,
                                            stdout=self.log_file,
                                            stderr=self.log_file,
&amp;gt;                                           stdin=PIPE)
../venv/lib/python3.5/site-packages/selenium/webdriver/common/service.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = &amp;lt;subprocess.Popen object at 0x7fd154fdf908&amp;gt;
args = [&amp;#39;geckodriver&amp;#39;, &amp;#39;--port&amp;#39;, &amp;#39;48151&amp;#39;], bufsize = -1, executable = None
stdin = -1
stdout = &amp;lt;_io.TextIOWrapper name=&amp;#39;geckodriver.log&amp;#39; mode=&amp;#39;a+&amp;#39; encoding=&amp;#39;UTF-8&amp;#39;&amp;gt;
stderr = &amp;lt;_io.TextIOWrapper name=&amp;#39;geckodriver.log&amp;#39; mode=&amp;#39;a+&amp;#39; encoding=&amp;#39;UTF-8&amp;#39;&amp;gt;
preexec_fn = None, close_fds = True, shell = False, cwd = None
env = environ({&amp;#39;PYTHONPATH&amp;#39;: &amp;#39;/home/sqa-user/Apps/pycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;GDM_LANG&amp;#39;: &amp;#39;en_US&amp;#39;, &amp;#39;XDG_SES...ycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;QT_ACCESSIBILITY&amp;#39;: &amp;#39;1&amp;#39;, &amp;#39;GNOME_DESKTOP_SESSION_ID&amp;#39;: &amp;#39;this-is-deprecated&amp;#39;})
universal_newlines = False, startupinfo = None, creationflags = 0
restore_signals = True, start_new_session = False, pass_fds = ()
    def __init__(self, args, bufsize=-1, executable=None,
                 stdin=None, stdout=None, stderr=None,
                 preexec_fn=None, close_fds=_PLATFORM_DEFAULT_CLOSE_FDS,
                 shell=False, cwd=None, env=None, universal_newlines=False,
                 startupinfo=None, creationflags=0,
                 restore_signals=True, start_new_session=False,
                 pass_fds=()):
        &amp;quot;&amp;quot;&amp;quot;Create new Popen instance.&amp;quot;&amp;quot;&amp;quot;
        _cleanup()
        # Held while anything is calling waitpid before returncode has been
        # updated to prevent clobbering returncode if wait() or poll() are
        # called from multiple threads at once.  After acquiring the lock,
        # code must re-check self.returncode to see if another thread just
        # finished a waitpid() call.
        self._waitpid_lock = threading.Lock()
    
        self._input = None
        self._communication_started = False
        if bufsize is None:
            bufsize = -1  # Restore default
        if not isinstance(bufsize, int):
            raise TypeError(&amp;quot;bufsize must be an integer&amp;quot;)
    
        if _mswindows:
            if preexec_fn is not None:
                raise ValueError(&amp;quot;preexec_fn is not supported on Windows &amp;quot;
                                 &amp;quot;platforms&amp;quot;)
            any_stdio_set = (stdin is not None or stdout is not None or
                             stderr is not None)
            if close_fds is _PLATFORM_DEFAULT_CLOSE_FDS:
                if any_stdio_set:
                    close_fds = False
                else:
                    close_fds = True
            elif close_fds and any_stdio_set:
                raise ValueError(
                        &amp;quot;close_fds is not supported on Windows platforms&amp;quot;
                        &amp;quot; if you redirect stdin/stdout/stderr&amp;quot;)
        else:
            # POSIX
            if close_fds is _PLATFORM_DEFAULT_CLOSE_FDS:
                close_fds = True
            if pass_fds and not close_fds:
                warnings.warn(&amp;quot;pass_fds overriding close_fds.&amp;quot;, RuntimeWarning)
                close_fds = True
            if startupinfo is not None:
                raise ValueError(&amp;quot;startupinfo is only supported on Windows &amp;quot;
                                 &amp;quot;platforms&amp;quot;)
            if creationflags != 0:
                raise ValueError(&amp;quot;creationflags is only supported on Windows &amp;quot;
                                 &amp;quot;platforms&amp;quot;)
    
        self.args = args
        self.stdin = None
        self.stdout = None
        self.stderr = None
        self.pid = None
        self.returncode = None
        self.universal_newlines = universal_newlines
    
        # Input and output objects. The general principle is like
        # this:
        #
        # Parent                   Child
        # ------                   -----
        # p2cwrite   ---stdin---&amp;gt;  p2cread
        # c2pread    &amp;lt;--stdout---  c2pwrite
        # errread    &amp;lt;--stderr---  errwrite
        #
        # On POSIX, the child objects are file descriptors.  On
        # Windows, these are Windows file handles.  The parent objects
        # are file descriptors on both platforms.  The parent objects
        # are -1 when not using PIPEs. The child objects are -1
        # when not redirecting.
    
        (p2cread, p2cwrite,
         c2pread, c2pwrite,
         errread, errwrite) = self._get_handles(stdin, stdout, stderr)
    
        # We wrap OS handles *before* launching the child, otherwise a
        # quickly terminating child could make our fds unwrappable
        # (see #8458).
    
        if _mswindows:
            if p2cwrite != -1:
                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)
            if c2pread != -1:
                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)
            if errread != -1:
                errread = msvcrt.open_osfhandle(errread.Detach(), 0)
    
        if p2cwrite != -1:
            self.stdin = io.open(p2cwrite, &amp;#39;wb&amp;#39;, bufsize)
            if universal_newlines:
                self.stdin = io.TextIOWrapper(self.stdin, write_through=True,
                                              line_buffering=(bufsize == 1))
        if c2pread != -1:
            self.stdout = io.open(c2pread, &amp;#39;rb&amp;#39;, bufsize)
            if universal_newlines:
                self.stdout = io.TextIOWrapper(self.stdout)
        if errread != -1:
            self.stderr = io.open(errread, &amp;#39;rb&amp;#39;, bufsize)
            if universal_newlines:
                self.stderr = io.TextIOWrapper(self.stderr)
    
        self._closed_child_pipe_fds = False
        try:
            self._execute_child(args, executable, preexec_fn, close_fds,
                                pass_fds, cwd, env,
                                startupinfo, creationflags, shell,
                                p2cread, p2cwrite,
                                c2pread, c2pwrite,
                                errread, errwrite,
&amp;gt;                               restore_signals, start_new_session)
/usr/lib/python3.5/subprocess.py:947: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = &amp;lt;subprocess.Popen object at 0x7fd154fdf908&amp;gt;
args = [&amp;#39;geckodriver&amp;#39;, &amp;#39;--port&amp;#39;, &amp;#39;48151&amp;#39;], executable = b&amp;#39;geckodriver&amp;#39;
preexec_fn = None, close_fds = True, pass_fds = (), cwd = None
env = environ({&amp;#39;PYTHONPATH&amp;#39;: &amp;#39;/home/sqa-user/Apps/pycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;GDM_LANG&amp;#39;: &amp;#39;en_US&amp;#39;, &amp;#39;XDG_SES...ycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;QT_ACCESSIBILITY&amp;#39;: &amp;#39;1&amp;#39;, &amp;#39;GNOME_DESKTOP_SESSION_ID&amp;#39;: &amp;#39;this-is-deprecated&amp;#39;})
startupinfo = None, creationflags = 0, shell = False, p2cread = 14
p2cwrite = 15, c2pread = -1, c2pwrite = 13, errread = -1, errwrite = 13
restore_signals = True, start_new_session = False
    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals, start_new_session):
        &amp;quot;&amp;quot;&amp;quot;Execute program (POSIX version)&amp;quot;&amp;quot;&amp;quot;
    
        if isinstance(args, (str, bytes)):
            args = [args]
        else:
            args = list(args)
    
        if shell:
            args = [&amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: &amp;quot;exception name:hex errno:description&amp;quot;
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write &amp;lt; 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = [os.fsencode(k) + b&amp;#39;=&amp;#39; + os.fsencode(v)
                                for k, v in env.items()]
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, sorted(fds_to_keep), cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session, preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            # self._devnull is not always defined.
            devnull_fd = getattr(self, &amp;#39;_devnull&amp;#39;, None)
            if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                os.close(p2cread)
            if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                os.close(c2pwrite)
            if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                os.close(errwrite)
            if devnull_fd is not None:
                os.close(devnull_fd)
            # Prevent a double close of these fds from __init__ on error.
            self._closed_child_pipe_fds = True
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) &amp;gt; 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                os.waitpid(self.pid, 0)
            except ChildProcessError:
                pass
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b&amp;#39;:&amp;#39;, 2))
            except ValueError:
                exception_name = b&amp;#39;SubprocessError&amp;#39;
                hex_errno = b&amp;#39;0&amp;#39;
                err_msg = (b&amp;#39;Bad exception data from child: &amp;#39; +
                           repr(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode(&amp;#39;ascii&amp;#39;),
                    SubprocessError)
            err_msg = err_msg.decode(errors=&amp;quot;surrogatepass&amp;quot;)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == &amp;quot;noexec&amp;quot;)
                if child_exec_never_called:
                    err_msg = &amp;quot;&amp;quot;
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
                    if errno_num == errno.ENOENT:
                        if child_exec_never_called:
                            # The error must be from chdir(cwd).
                            err_msg += &amp;#39;: &amp;#39; + repr(cwd)
                        else:
                            err_msg += &amp;#39;: &amp;#39; + repr(orig_executable)
&amp;gt;               raise child_exception_type(errno_num, err_msg)
E               FileNotFoundError: [Errno 2] No such file or directory: &amp;#39;geckodriver&amp;#39;
/usr/lib/python3.5/subprocess.py:1551: FileNotFoundError
During handling of the above exception, another exception occurred:
request = &amp;lt;SubRequest &amp;#39;apl&amp;#39; for &amp;lt;Function &amp;#39;test_create_contact[None:lastnameOVeqDC:firstnameeRUcgTidXuC:address  .9TM dLMpKBi Z576eyiY9yiI9]&amp;#39;&amp;gt;&amp;gt;
    @pytest.fixture
    def apl(request):
        global fixture
        browser = request.config.getoption(&amp;quot;--browser&amp;quot;)
        web_config= load_config(request.config.getoption(&amp;quot;--target&amp;quot;))[&amp;quot;web&amp;quot;]
        if fixture is None or not fixture.is_valid():
&amp;gt;           fixture = Aplicant(browser=browser, base_url=web_config[&amp;quot;baseUrl&amp;quot;])
../conftest.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../fixture/aplicanter.py:12: in __init__
    self.wd = webdriver.Firefox()
../venv/lib/python3.5/site-packages/selenium/webdriver/firefox/webdriver.py:152: in __init__
    self.service.start()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = &amp;lt;selenium.webdriver.firefox.service.Service object at 0x7fd154fdf7f0&amp;gt;
    def start(self):
        &amp;quot;&amp;quot;&amp;quot;
            Starts the Service.
    
            :Exceptions:
             - WebDriverException : Raised either when it can&amp;#39;t start the service
               or when it can&amp;#39;t connect to the service
            &amp;quot;&amp;quot;&amp;quot;
        try:
            cmd = [self.path]
            cmd.extend(self.command_line_args())
            self.process = subprocess.Popen(cmd, env=self.env,
                                            close_fds=platform.system() != &amp;#39;Windows&amp;#39;,
                                            stdout=self.log_file,
                                            stderr=self.log_file,
                                            stdin=PIPE)
        except TypeError:
            raise
        except OSError as err:
            if err.errno == errno.ENOENT:
                raise WebDriverException(
                    &amp;quot;&amp;#39;%s&amp;#39; executable needs to be in PATH. %s&amp;quot; % (
&amp;gt;                       os.path.basename(self.path), self.start_error_message)
E                       selenium.common.exceptions.WebDriverException: Message: &amp;#39;geckodriver&amp;#39; executable needs to be in PATH.
../venv/lib/python3.5/site-packages/selenium/webdriver/common/service.py:83: WebDriverException
</output>
            </test>
            <test duration="8" locationUrl="python&lt;/home/sqa-user/PycharmProjects/Python_for_testers/tests&gt;://test_create_contact.test_create_contact." name="(None:lastnameV  :firstnames w qqM:addressQXWZXIjfe7ZxTwc9 l,8Vl)" status="failed">
                <output type="stdout">E
</output>
                <output type="stderr">test setup failed
self = &amp;lt;selenium.webdriver.firefox.service.Service object at 0x7fd154f3b8d0&amp;gt;
    def start(self):
        &amp;quot;&amp;quot;&amp;quot;
            Starts the Service.
    
            :Exceptions:
             - WebDriverException : Raised either when it can&amp;#39;t start the service
               or when it can&amp;#39;t connect to the service
            &amp;quot;&amp;quot;&amp;quot;
        try:
            cmd = [self.path]
            cmd.extend(self.command_line_args())
            self.process = subprocess.Popen(cmd, env=self.env,
                                            close_fds=platform.system() != &amp;#39;Windows&amp;#39;,
                                            stdout=self.log_file,
                                            stderr=self.log_file,
&amp;gt;                                           stdin=PIPE)
../venv/lib/python3.5/site-packages/selenium/webdriver/common/service.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = &amp;lt;subprocess.Popen object at 0x7fd154f3bcf8&amp;gt;
args = [&amp;#39;geckodriver&amp;#39;, &amp;#39;--port&amp;#39;, &amp;#39;45331&amp;#39;], bufsize = -1, executable = None
stdin = -1
stdout = &amp;lt;_io.TextIOWrapper name=&amp;#39;geckodriver.log&amp;#39; mode=&amp;#39;a+&amp;#39; encoding=&amp;#39;UTF-8&amp;#39;&amp;gt;
stderr = &amp;lt;_io.TextIOWrapper name=&amp;#39;geckodriver.log&amp;#39; mode=&amp;#39;a+&amp;#39; encoding=&amp;#39;UTF-8&amp;#39;&amp;gt;
preexec_fn = None, close_fds = True, shell = False, cwd = None
env = environ({&amp;#39;PYTHONPATH&amp;#39;: &amp;#39;/home/sqa-user/Apps/pycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;GDM_LANG&amp;#39;: &amp;#39;en_US&amp;#39;, &amp;#39;XDG_SES...ycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;QT_ACCESSIBILITY&amp;#39;: &amp;#39;1&amp;#39;, &amp;#39;GNOME_DESKTOP_SESSION_ID&amp;#39;: &amp;#39;this-is-deprecated&amp;#39;})
universal_newlines = False, startupinfo = None, creationflags = 0
restore_signals = True, start_new_session = False, pass_fds = ()
    def __init__(self, args, bufsize=-1, executable=None,
                 stdin=None, stdout=None, stderr=None,
                 preexec_fn=None, close_fds=_PLATFORM_DEFAULT_CLOSE_FDS,
                 shell=False, cwd=None, env=None, universal_newlines=False,
                 startupinfo=None, creationflags=0,
                 restore_signals=True, start_new_session=False,
                 pass_fds=()):
        &amp;quot;&amp;quot;&amp;quot;Create new Popen instance.&amp;quot;&amp;quot;&amp;quot;
        _cleanup()
        # Held while anything is calling waitpid before returncode has been
        # updated to prevent clobbering returncode if wait() or poll() are
        # called from multiple threads at once.  After acquiring the lock,
        # code must re-check self.returncode to see if another thread just
        # finished a waitpid() call.
        self._waitpid_lock = threading.Lock()
    
        self._input = None
        self._communication_started = False
        if bufsize is None:
            bufsize = -1  # Restore default
        if not isinstance(bufsize, int):
            raise TypeError(&amp;quot;bufsize must be an integer&amp;quot;)
    
        if _mswindows:
            if preexec_fn is not None:
                raise ValueError(&amp;quot;preexec_fn is not supported on Windows &amp;quot;
                                 &amp;quot;platforms&amp;quot;)
            any_stdio_set = (stdin is not None or stdout is not None or
                             stderr is not None)
            if close_fds is _PLATFORM_DEFAULT_CLOSE_FDS:
                if any_stdio_set:
                    close_fds = False
                else:
                    close_fds = True
            elif close_fds and any_stdio_set:
                raise ValueError(
                        &amp;quot;close_fds is not supported on Windows platforms&amp;quot;
                        &amp;quot; if you redirect stdin/stdout/stderr&amp;quot;)
        else:
            # POSIX
            if close_fds is _PLATFORM_DEFAULT_CLOSE_FDS:
                close_fds = True
            if pass_fds and not close_fds:
                warnings.warn(&amp;quot;pass_fds overriding close_fds.&amp;quot;, RuntimeWarning)
                close_fds = True
            if startupinfo is not None:
                raise ValueError(&amp;quot;startupinfo is only supported on Windows &amp;quot;
                                 &amp;quot;platforms&amp;quot;)
            if creationflags != 0:
                raise ValueError(&amp;quot;creationflags is only supported on Windows &amp;quot;
                                 &amp;quot;platforms&amp;quot;)
    
        self.args = args
        self.stdin = None
        self.stdout = None
        self.stderr = None
        self.pid = None
        self.returncode = None
        self.universal_newlines = universal_newlines
    
        # Input and output objects. The general principle is like
        # this:
        #
        # Parent                   Child
        # ------                   -----
        # p2cwrite   ---stdin---&amp;gt;  p2cread
        # c2pread    &amp;lt;--stdout---  c2pwrite
        # errread    &amp;lt;--stderr---  errwrite
        #
        # On POSIX, the child objects are file descriptors.  On
        # Windows, these are Windows file handles.  The parent objects
        # are file descriptors on both platforms.  The parent objects
        # are -1 when not using PIPEs. The child objects are -1
        # when not redirecting.
    
        (p2cread, p2cwrite,
         c2pread, c2pwrite,
         errread, errwrite) = self._get_handles(stdin, stdout, stderr)
    
        # We wrap OS handles *before* launching the child, otherwise a
        # quickly terminating child could make our fds unwrappable
        # (see #8458).
    
        if _mswindows:
            if p2cwrite != -1:
                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)
            if c2pread != -1:
                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)
            if errread != -1:
                errread = msvcrt.open_osfhandle(errread.Detach(), 0)
    
        if p2cwrite != -1:
            self.stdin = io.open(p2cwrite, &amp;#39;wb&amp;#39;, bufsize)
            if universal_newlines:
                self.stdin = io.TextIOWrapper(self.stdin, write_through=True,
                                              line_buffering=(bufsize == 1))
        if c2pread != -1:
            self.stdout = io.open(c2pread, &amp;#39;rb&amp;#39;, bufsize)
            if universal_newlines:
                self.stdout = io.TextIOWrapper(self.stdout)
        if errread != -1:
            self.stderr = io.open(errread, &amp;#39;rb&amp;#39;, bufsize)
            if universal_newlines:
                self.stderr = io.TextIOWrapper(self.stderr)
    
        self._closed_child_pipe_fds = False
        try:
            self._execute_child(args, executable, preexec_fn, close_fds,
                                pass_fds, cwd, env,
                                startupinfo, creationflags, shell,
                                p2cread, p2cwrite,
                                c2pread, c2pwrite,
                                errread, errwrite,
&amp;gt;                               restore_signals, start_new_session)
/usr/lib/python3.5/subprocess.py:947: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = &amp;lt;subprocess.Popen object at 0x7fd154f3bcf8&amp;gt;
args = [&amp;#39;geckodriver&amp;#39;, &amp;#39;--port&amp;#39;, &amp;#39;45331&amp;#39;], executable = b&amp;#39;geckodriver&amp;#39;
preexec_fn = None, close_fds = True, pass_fds = (), cwd = None
env = environ({&amp;#39;PYTHONPATH&amp;#39;: &amp;#39;/home/sqa-user/Apps/pycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;GDM_LANG&amp;#39;: &amp;#39;en_US&amp;#39;, &amp;#39;XDG_SES...ycharm-community-2017.3.2/helpers/pycharm&amp;#39;, &amp;#39;QT_ACCESSIBILITY&amp;#39;: &amp;#39;1&amp;#39;, &amp;#39;GNOME_DESKTOP_SESSION_ID&amp;#39;: &amp;#39;this-is-deprecated&amp;#39;})
startupinfo = None, creationflags = 0, shell = False, p2cread = 15
p2cwrite = 16, c2pread = -1, c2pwrite = 14, errread = -1, errwrite = 14
restore_signals = True, start_new_session = False
    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals, start_new_session):
        &amp;quot;&amp;quot;&amp;quot;Execute program (POSIX version)&amp;quot;&amp;quot;&amp;quot;
    
        if isinstance(args, (str, bytes)):
            args = [args]
        else:
            args = list(args)
    
        if shell:
            args = [&amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: &amp;quot;exception name:hex errno:description&amp;quot;
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write &amp;lt; 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = [os.fsencode(k) + b&amp;#39;=&amp;#39; + os.fsencode(v)
                                for k, v in env.items()]
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _posixsubprocess.fork_exec(
                        args, executable_list,
                        close_fds, sorted(fds_to_keep), cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session, preexec_fn)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            # self._devnull is not always defined.
            devnull_fd = getattr(self, &amp;#39;_devnull&amp;#39;, None)
            if p2cread != -1 and p2cwrite != -1 and p2cread != devnull_fd:
                os.close(p2cread)
            if c2pwrite != -1 and c2pread != -1 and c2pwrite != devnull_fd:
                os.close(c2pwrite)
            if errwrite != -1 and errread != -1 and errwrite != devnull_fd:
                os.close(errwrite)
            if devnull_fd is not None:
                os.close(devnull_fd)
            # Prevent a double close of these fds from __init__ on error.
            self._closed_child_pipe_fds = True
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) &amp;gt; 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                os.waitpid(self.pid, 0)
            except ChildProcessError:
                pass
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b&amp;#39;:&amp;#39;, 2))
            except ValueError:
                exception_name = b&amp;#39;SubprocessError&amp;#39;
                hex_errno = b&amp;#39;0&amp;#39;
                err_msg = (b&amp;#39;Bad exception data from child: &amp;#39; +
                           repr(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode(&amp;#39;ascii&amp;#39;),
                    SubprocessError)
            err_msg = err_msg.decode(errors=&amp;quot;surrogatepass&amp;quot;)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                child_exec_never_called = (err_msg == &amp;quot;noexec&amp;quot;)
                if child_exec_never_called:
                    err_msg = &amp;quot;&amp;quot;
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
                    if errno_num == errno.ENOENT:
                        if child_exec_never_called:
                            # The error must be from chdir(cwd).
                            err_msg += &amp;#39;: &amp;#39; + repr(cwd)
                        else:
                            err_msg += &amp;#39;: &amp;#39; + repr(orig_executable)
&amp;gt;               raise child_exception_type(errno_num, err_msg)
E               FileNotFoundError: [Errno 2] No such file or directory: &amp;#39;geckodriver&amp;#39;
/usr/lib/python3.5/subprocess.py:1551: FileNotFoundError
During handling of the above exception, another exception occurred:
request = &amp;lt;SubRequest &amp;#39;apl&amp;#39; for &amp;lt;Function &amp;#39;test_create_contact[None:lastnameV  :firstnames w qqM:addressQXWZXIjfe7ZxTwc9 l,8Vl]&amp;#39;&amp;gt;&amp;gt;
    @pytest.fixture
    def apl(request):
        global fixture
        browser = request.config.getoption(&amp;quot;--browser&amp;quot;)
        web_config= load_config(request.config.getoption(&amp;quot;--target&amp;quot;))[&amp;quot;web&amp;quot;]
        if fixture is None or not fixture.is_valid():
&amp;gt;           fixture = Aplicant(browser=browser, base_url=web_config[&amp;quot;baseUrl&amp;quot;])
../conftest.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../fixture/aplicanter.py:12: in __init__
    self.wd = webdriver.Firefox()
../venv/lib/python3.5/site-packages/selenium/webdriver/firefox/webdriver.py:152: in __init__
    self.service.start()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
self = &amp;lt;selenium.webdriver.firefox.service.Service object at 0x7fd154f3b8d0&amp;gt;
    def start(self):
        &amp;quot;&amp;quot;&amp;quot;
            Starts the Service.
    
            :Exceptions:
             - WebDriverException : Raised either when it can&amp;#39;t start the service
               or when it can&amp;#39;t connect to the service
            &amp;quot;&amp;quot;&amp;quot;
        try:
            cmd = [self.path]
            cmd.extend(self.command_line_args())
            self.process = subprocess.Popen(cmd, env=self.env,
                                            close_fds=platform.system() != &amp;#39;Windows&amp;#39;,
                                            stdout=self.log_file,
                                            stderr=self.log_file,
                                            stdin=PIPE)
        except TypeError:
            raise
        except OSError as err:
            if err.errno == errno.ENOENT:
                raise WebDriverException(
                    &amp;quot;&amp;#39;%s&amp;#39; executable needs to be in PATH. %s&amp;quot; % (
&amp;gt;                       os.path.basename(self.path), self.start_error_message)
E                       selenium.common.exceptions.WebDriverException: Message: &amp;#39;geckodriver&amp;#39; executable needs to be in PATH.
../venv/lib/python3.5/site-packages/selenium/webdriver/common/service.py:83: WebDriverException
</output>
            </test>
        </suite>
        <test duration="4" locationUrl="python&lt;/home/sqa-user/PycharmProjects/Python_for_testers/tests&gt;://test_create_contact.test_create_contact" name="test_create_contact(None:lastnameV  :firstnames w qqM:addressQXWZXIjfe7ZxTwc9 l,8Vl)_teardown" status="failed">
            <output type="stderr">test_create_contact.py:4 (test_create_contact[None:lastnameV  :firstnames w qqM:addressQXWZXIjfe7ZxTwc9 l,8Vl])
def fin():
&amp;gt;       fixture.session.ensure_logout()
E       AttributeError: &amp;#39;NoneType&amp;#39; object has no attribute &amp;#39;session&amp;#39;
../conftest.py:64: AttributeError
</output>
        </test>
    </suite>
</testrun>
